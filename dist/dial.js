(()=>{var e={1:e=>{e.exports="#extension GL_OES_standard_derivatives : enable\n\n#ifdef GL_FRAGMENT_PRECISION_HIGH\nprecision highp float;\n#else\nprecision mediump float;\n#endif\n\nvarying vec2 vUv;\n\nuniform sampler2D uMap;\nuniform float uRadius;\nuniform float uInnerRadius;\nuniform float uThetaStart;   // −π to +π\nuniform float uThetaEnd;   // −π to +π\nuniform float uThetaMid;   // −π to +π\nuniform vec3 uWedgeColor;\nuniform vec3 uRingBackgroundColor;\nuniform vec3 uBackgroundColor;\n\nvoid main() {\n    const vec2 center = vec2(0.5, 0.5);\n\n    vec2 diff = vUv - center;\n    float theta = atan(diff.x, diff.y);\n    float radius = length(diff);\n#ifdef GL_OES_standard_derivatives\n    float linearEdge = length(vec2(dFdx(vUv.x), dFdy(vUv.y)));\n    float radialEdge = linearEdge / max(radius, 0.03);\n#else\n    float linearEdge = 0.005 * gl_FragCoord.z / gl_FragCoord.w;\n    float radialEdge = linearEdge / max(radius, 0.03);\n#endif\n    vec3 ringColor = uThetaStart == uThetaEnd ?\n        uBackgroundColor :\n        mix(uWedgeColor, uRingBackgroundColor,\n            smoothstep(-radialEdge, +radialEdge, theta < uThetaMid ? uThetaStart - theta :  theta - uThetaEnd));\n\n    vec3 dynamicColor = mix(uBackgroundColor, ringColor, smoothstep(-linearEdge, +linearEdge, radius - uInnerRadius));\n\n    vec4 diskColor = vec4(dynamicColor, 1.0);\n\n    vec4 texel = texture2D(uMap, vUv);\n    gl_FragColor = radius < uRadius ? mix(diskColor, texel, texel.a) : texel;\n}\n"},109:e=>{e.exports="// = object.matrixWorld\nuniform mat4 modelMatrix;\n\n// = camera.matrixWorldInverse * object.matrixWorld\nuniform mat4 modelViewMatrix;\n\n// = camera.projectionMatrix\nuniform mat4 projectionMatrix;\n\n// = camera.matrixWorldInverse\nuniform mat4 viewMatrix;\n\n// = inverse transpose of modelViewMatrix\nuniform mat3 normalMatrix;\n\n// = camera position in world space\nuniform vec3 cameraPosition;\n// default vertex attributes provided by Geometry and BufferGeometry\nattribute vec3 position;\nattribute vec3 normal;\nattribute vec2 uv;\n\nvarying vec2 vUv;\n\nvoid main() {\n    vUv = uv;\n    gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);\n}\n"}},t={};function a(r){if(t[r])return t[r].exports;var n=t[r]={exports:{}};return e[r](n,n.exports,a),n.exports}a.n=e=>{var t=e&&e.__esModule?()=>e.default:()=>e;return a.d(t,{a:t}),t},a.d=(e,t)=>{for(var r in t)a.o(t,r)&&!a.o(e,r)&&Object.defineProperty(e,r,{enumerable:!0,get:t[r]})},a.o=(e,t)=>Object.prototype.hasOwnProperty.call(e,t),(()=>{"use strict";var e=a(109),t=a.n(e),r=a(1),n=a.n(r);AFRAME.registerComponent("dial",{schema:{size:{default:.25,min:.01},src:{type:"map"},radius:{default:.98,min:0},innerRadius:{default:0,min:0},thetaStart:{default:0},thetaEnd:{default:230},wedgeColor:{type:"color",default:"black"},backgroundColor:{type:"color",default:"white"}},init:function(){this.initGeometry(this.data.size),this.initShader(this.data);const e=new THREE.Mesh(this.geometry,this.shaderMaterial);this.el.setObject3D("mesh",e)},initGeometry:function(e){const t=this.geometry=new THREE.BufferGeometry,a=e/2,r=[-a,-a,0,a,-a,0,-a,a,0,a,a,0];t.setIndex([3,2,0,0,1,3]),t.setAttribute("position",new THREE.Float32BufferAttribute(r,3)),t.setAttribute("uv",new THREE.Float32BufferAttribute([0,0,1,0,0,1,1,1],2))},initShader:function(e){const a=this.el.sceneEl.canvas.getContext("webgl");a&&a.getExtension("OES_standard_derivatives"),this.uniforms={uMap:{type:"t"},uRadius:{type:"f"},uInnerRadius:{type:"f"},uThetaStart:{type:"f"},uThetaEnd:{type:"f"},uThetaMid:{type:"f"},uWedgeColor:{type:"v3"},uRingBackgroundColor:{type:"v3"},uBackgroundColor:{type:"v3"}},this.shaderMaterial=new THREE.RawShaderMaterial({uniforms:this.uniforms,vertexShader:t(),fragmentShader:n(),transparent:!0}),this.textureLoader=new THREE.TextureLoader},update:function(e){this.uniforms.uRadius.value=this.data.radius/2,this.uniforms.uInnerRadius.value=Math.min(this.data.innerRadius/2,this.uniforms.uRadius.value-.01);let t=this.data.thetaStart,a=this.data.thetaEnd,r=this.data.wedgeColor,n=this.data.backgroundColor;for(a-t>=360&&(t=-180,a=180);t<-180;)t+=360;for(;t>180;)t-=360;for(;a<-180;)a+=360;for(;a>180;)a-=360;if(a<t){const e=a;a=t,t=e,r=this.data.backgroundColor,n=this.data.wedgeColor}this.uniforms.uThetaStart.value=t*Math.PI/180,this.uniforms.uThetaEnd.value=a*Math.PI/180,this.uniforms.uThetaMid.value=(this.uniforms.uThetaStart.value+this.uniforms.uThetaEnd.value)/2,this.uniforms.uWedgeColor.value=new THREE.Color(r),this.uniforms.uRingBackgroundColor.value=new THREE.Color(n),this.uniforms.uBackgroundColor.value=new THREE.Color(this.data.backgroundColor),this.data.src!==e.src&&this.textureLoader.load(this.data.src.currentSrc,(e=>{this.shaderMaterial.uniforms.uMap.value=e,e.wrapS=e.wrapT=THREE.ClampToEdgeWrapping,e.magFilfer=THREE.LinearFilter}))}})})()})();