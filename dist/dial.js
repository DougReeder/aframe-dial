(()=>{var t={1:t=>{t.exports="varying vec2 vUv;\n\nuniform sampler2D uMap;\nuniform float uRadius;\nuniform float uThetaStart;   // −π to +π\nuniform float uThetaEnd;   // −π to +π\nuniform vec3 uWedgeColor;\nuniform vec3 uBackgroundColor;\n\nvoid main() {\n    const vec2 center = vec2(0.5, 0.5);\n\n    vec2 diff = vUv - center;\n    float theta = atan(diff.x, diff.y);\n    vec3 dynamicColor = (theta > uThetaStart && theta < uThetaEnd) ? uWedgeColor : uBackgroundColor;\n\n    float radius = length(diff);\n    vec4 diskColor = vec4(dynamicColor, radius < uRadius ? 1.0 : 0.0);\n\n    vec4 texel = texture2D(uMap, vUv);\n    vec4 resultColor = mix(diskColor, texel, texel.a);\n    if (resultColor.a < 0.5)\n        discard;\n    gl_FragColor = resultColor;\n}\n"},109:t=>{t.exports="varying vec2 vUv;\n\nvoid main() {\n    vUv = uv;\n    gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);\n}\n"}},e={};function r(a){if(e[a])return e[a].exports;var o=e[a]={exports:{}};return t[a](o,o.exports,r),o.exports}r.n=t=>{var e=t&&t.__esModule?()=>t.default:()=>t;return r.d(e,{a:e}),e},r.d=(t,e)=>{for(var a in e)r.o(e,a)&&!r.o(t,a)&&Object.defineProperty(t,a,{enumerable:!0,get:e[a]})},r.o=(t,e)=>Object.prototype.hasOwnProperty.call(t,e),(()=>{"use strict";var t=r(109),e=r.n(t),a=r(1),o=r.n(a);AFRAME.registerComponent("dial",{schema:{src:{type:"map"},radius:{default:.98},thetaStart:{default:0},thetaEnd:{default:230},wedgeColor:{type:"color",default:"black"},backgroundColor:{type:"color",default:"white"}},init:function(){this.initGeometry(),this.initShader(this.data);const t=new THREE.Mesh(this.geometry,this.shader);this.el.setObject3D("mesh",t)},initGeometry:function(){const t=this.geometry=new THREE.BufferGeometry,e=.4,r=[-.4,-.4,0,e,-.4,0,-.4,e,0,e,e,0];t.setIndex([3,2,0,0,1,3]),t.setAttribute("position",new THREE.Float32BufferAttribute(r,3)),t.setAttribute("uv",new THREE.Float32BufferAttribute([0,0,1,0,0,1,1,1],2))},initShader:function(t){this.uniforms={uMap:{type:"t",value:null},uRadius:{type:"f",value:t.radius/2},uThetaStart:{type:"f",value:t.thetaStart*Math.PI/180},uThetaEnd:{type:"f",value:t.thetaEnd*Math.PI/180},uWedgeColor:{type:"v3",value:new THREE.Color(t.wedgeColor)},uBackgroundColor:{type:"v3",value:new THREE.Color(t.backgroundColor)}};const r=this.shader=new THREE.ShaderMaterial({uniforms:this.uniforms,vertexShader:e(),fragmentShader:o()});(new THREE.TextureLoader).load(t.src.currentSrc,(t=>{r.uniforms.uMap.value=t,t.wrapS=t.wrapT=THREE.ClampToEdgeWrapping,t.magFilfer=THREE.LinearFilter}))},update:function(){this.uniforms.uRadius.value=this.data.radius/2,this.uniforms.uThetaStart.value=this.data.thetaStart*Math.PI/180,this.uniforms.uThetaEnd.value=this.data.thetaEnd*Math.PI/180,this.uniforms.uWedgeColor.value=new THREE.Color(this.data.wedgeColor),this.uniforms.uBackgroundColor.value=new THREE.Color(this.data.backgroundColor)}})})()})();