(()=>{var t={1:t=>{t.exports="#version 300 es\n\nprecision mediump float;\n\nin vec2 vUv;\n\nuniform sampler2D uMap;\nuniform float uRadius;\nuniform float uThetaStart;   // −π to +π\nuniform float uThetaEnd;   // −π to +π\nuniform float uThetaMid;   // −π to +π\nuniform vec3 uWedgeColor;\nuniform vec3 uBackgroundColor;\n\nout vec4 outColor;\n\nvoid main() {\n    const vec2 center = vec2(0.5, 0.5);\n\n    vec2 diff = vUv - center;\n    float theta = atan(diff.x, diff.y);\n    float radius = length(diff);\n    float edge = length(vec2(dFdx(vUv.x), dFdy(vUv.y))) / max(radius, 0.02);\n    vec3 dynamicColor = uThetaStart == uThetaEnd ?\n        uBackgroundColor :\n        mix(uWedgeColor, uBackgroundColor,\n            smoothstep(-edge, +edge, theta < uThetaMid ? uThetaStart - theta :  theta - uThetaEnd));\n    vec4 diskColor = vec4(dynamicColor, 1.0);\n\n    vec4 texel = texture(uMap, vUv);\n    outColor = radius < uRadius ? mix(diskColor, texel, texel.a) : texel;\n}\n"},109:t=>{t.exports="#version 300 es\n\n// = object.matrixWorld\nuniform mat4 modelMatrix;\n\n// = camera.matrixWorldInverse * object.matrixWorld\nuniform mat4 modelViewMatrix;\n\n// = camera.projectionMatrix\nuniform mat4 projectionMatrix;\n\n// = camera.matrixWorldInverse\nuniform mat4 viewMatrix;\n\n// = inverse transpose of modelViewMatrix\nuniform mat3 normalMatrix;\n\n// = camera position in world space\nuniform vec3 cameraPosition;\n// default vertex attributes provided by Geometry and BufferGeometry\nin vec3 position;\nin vec3 normal;\nin vec2 uv;\n\nout vec2 vUv;\n\nvoid main() {\n    vUv = uv;\n    gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);\n}\n"}},e={};function r(a){if(e[a])return e[a].exports;var n=e[a]={exports:{}};return t[a](n,n.exports,r),n.exports}r.n=t=>{var e=t&&t.__esModule?()=>t.default:()=>t;return r.d(e,{a:e}),e},r.d=(t,e)=>{for(var a in e)r.o(e,a)&&!r.o(t,a)&&Object.defineProperty(t,a,{enumerable:!0,get:e[a]})},r.o=(t,e)=>Object.prototype.hasOwnProperty.call(t,e),(()=>{"use strict";var t=r(109),e=r.n(t),a=r(1),n=r.n(a);AFRAME.registerComponent("dial",{schema:{size:{default:.25,min:.01},src:{type:"map"},radius:{default:.98,min:0},thetaStart:{default:0},thetaEnd:{default:230},wedgeColor:{type:"color",default:"black"},backgroundColor:{type:"color",default:"white"}},init:function(){this.initGeometry(this.data.size),this.initShader(this.data);const t=new THREE.Mesh(this.geometry,this.shaderMaterial);this.el.setObject3D("mesh",t)},initGeometry:function(t){const e=this.geometry=new THREE.BufferGeometry,r=t/2,a=[-r,-r,0,r,-r,0,-r,r,0,r,r,0];e.setIndex([3,2,0,0,1,3]),e.setAttribute("position",new THREE.Float32BufferAttribute(a,3)),e.setAttribute("uv",new THREE.Float32BufferAttribute([0,0,1,0,0,1,1,1],2))},initShader:function(t){this.uniforms={uMap:{type:"t"},uRadius:{type:"f"},uThetaStart:{type:"f"},uThetaEnd:{type:"f"},uThetaMid:{type:"f"},uWedgeColor:{type:"v3"},uBackgroundColor:{type:"v3"}},this.shaderMaterial=new THREE.RawShaderMaterial({uniforms:this.uniforms,vertexShader:e(),fragmentShader:n(),transparent:!0}),this.textureLoader=new THREE.TextureLoader},update:function(t){this.uniforms.uRadius.value=this.data.radius/2;let e=this.data.thetaStart,r=this.data.thetaEnd,a=this.data.wedgeColor,n=this.data.backgroundColor;for(r-e>=360&&(e=-180,r=180);e<-180;)e+=360;for(;e>180;)e-=360;for(;r<-180;)r+=360;for(;r>180;)r-=360;if(r<e){const t=r;r=e,e=t;const o=a;a=n,n=o}this.uniforms.uThetaStart.value=e*Math.PI/180,this.uniforms.uThetaEnd.value=r*Math.PI/180,this.uniforms.uThetaMid.value=(this.uniforms.uThetaStart.value+this.uniforms.uThetaEnd.value)/2,this.uniforms.uWedgeColor.value=new THREE.Color(a),this.uniforms.uBackgroundColor.value=new THREE.Color(n),this.data.src!==t.src&&this.textureLoader.load(this.data.src.currentSrc,(t=>{this.shaderMaterial.uniforms.uMap.value=t,t.wrapS=t.wrapT=THREE.ClampToEdgeWrapping,t.magFilfer=THREE.LinearFilter}))}})})()})();